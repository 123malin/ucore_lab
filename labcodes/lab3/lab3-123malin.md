#实验三 虚拟内存管理

##练习一 给未被映射的地址映射上物理页
>设计实现过程：首先根据异常地址addr和mm->pgdir（页目录表）找到对应页表项page，如果不存在，则分配一块物理内存，并实现该物理内存与addr之间的map；否则根据addr和mm将磁盘中相应的页换入page中，并建立page与addr之间的map，最后设置该物理内存页是可交换的（与常驻内存相区别）。

[练习1.1] 请描述页目录项（PDE）和页表（PTE）中组成部分对ucore实现页替换算法的潜在用处
```
1.页表项中设置的访问位，修改位，驻留位，保护位等都在clock等页替换算法中有用到
2.当页表项的pte_p位为0时，页表项中的地址+页内偏移可以当做磁盘的扇区地址将页调入内存中。当页表项的pte_p位为1时，页表项中的地址+页内偏移是物理内存中的地址。
```
[练习1.2]如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事？
```
CPU在内核栈中保存现场，将EFLAGS，CS，EIP等进行压栈处理，然后进行页访问异常的服务例程
```
##练习二 补充完成基于FIFO的页面替换算法
>设计实现过程：在页面替换时，将页面从磁盘读入内存并建立和虚地址的链接后，需要调用swap_map_swappable函数，在该函数中，将该页面加入pra_list_head（所有可swappable的页面）链表尾部；然后在发生缺页时，需要实现FIFO算法，淘汰pra_list_head表头的页，该功能调用_fifo_swap_out_victim 函数以实现，

[练习2]如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
```
可以，利用页表项的访问位和修改位，访问内存时将页面访问位置为1，若涉及写页面操作则將修改位也置1,发生页面替换时，循环在链表中进行查找修改：按（访问位，修改位）有一下四种可能： （0,0):这就是被替换页，直接被替换 （0,1)：改为（0,0），并进行一次写回操作 （1,0)：改为（0,0） （1,1)：改为（0,1），下次改为（0,0）并写回。
1.需要被换出的页的特征是什么
	答：访问位和修改位都为0，且越靠近表头（越早加入内存的）
2.在ucore中如何判断具有这样特征的页
	答：利用页表项的访问位和修改位的值进行查找
3.何时进行换入和换出操作
	答：发生页访问异常page_default时进行换入操作，换入时发现内存分配的页面已满时进行换出操作
```
